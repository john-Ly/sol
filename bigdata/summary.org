* hash函数
  输入范围 -> hash -> hash_code%m  均匀分布在[0,m-1] 
  MD5 sha1
* 海量数据处理技巧
  hash 分流到不同的机器 然后合并
  hash_map  bit_map
** 分布式文件系统
1. 容灾 备份 分布式存储
2. 负载均衡策略
3. 如何重启失败的进程 重新分区
** map_reduce
*** N皇后多机并行求解
1. 单线程求解算法 
   一维数组
2. 多线程
   比如8皇后 根据对称性
   4个线程: (0,0) (0,1) (0,2) (0,3) 如果放置皇后求出可能的个数 只用求一遍即可
   9皇后需要5个线程  最后的结果需要汇聚到主线程
   
   甚至可以固定第一行低一列 然后放置第二行(可以划分更多的子问题  可以安排更多的线程)
*** 词频统计排序
**** 并行处理
  + wordCount
   0. 预处理文本 -> dict
   1. map 阶段生成 k:v -> word:1
   2. shuffle 采用哈希函数 将单词分布在不同的机器上(相同的单词会被分配在同一个机器上)
   3. reduce 针对相同的单词进行整合
  + Sort By Count
   0. 反转k:v  --> v:k  就是次数作为key
   1. shuffle 采用排序
**** 单机内存可以处理
   hash 计数 + 使用vector(sort by count) + 输出
**** 内存+磁盘
** 大数据排序
*** 10亿个IP地址排序 (IPV4)
  IPV4: (2^8)^4 = 2^32 = 43亿左右
  10亿IP -> 10亿 无符号整数 (4字节)
  申请2^32 bit的 bit_map (2^32/8/2^20 = 2^9 = 512MB)
  对10个地址 全部转换成整数 填满bit_map
  顺序输出bit_map 即排序
 
  map_reduce 可以分区
*** 10亿个年龄
   年龄有范围限制 [0, 200] 申请200个桶
   计数排序
*** 40亿 < 2^32 找出缺失的数
   根据内存进行划分
** 大数据topk
采用hash分流 和 堆结构排序
** 一致性hash算法
